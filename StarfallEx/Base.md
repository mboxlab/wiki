---
title: StarfallEx Основы
description: Тут ты научишься ставить чип
published: true
date: 2023-12-09T08:54:48.494Z
tags: starfallex
editor: markdown
dateCreated: 2023-12-08T18:14:10.434Z
---

> **Синтаксис** в программировании представляет собой свод правил, которые поясняют, как писать код на определенном языке. Они отображают, как размещать и комбинировать друг с другом команды, какие символы применять, как делать понятную структуру и прочее.
{.is-info}



> **Идентификаторы**^переменные^ в StarfallEx могут быть любой последовательностью из букв, цифр и символов подчеркивания, не начинающейся с цифры
{.is-info}

```lua
i
j 
i10 
_ij
aSomewhatLong____Name
_IMBIG

```

> мы **не можем** использовать cледующие слова в качестве идентификаторов так как они зарезервированы: **and break do else elseif end false goto for function if in local nil not or repeat return then true until while**
{.is-warning}


# Глобальные переменные

Глобальным переменным не нужны объявления **вы их просто используете**. 
Обратиться к неинициализированной переменной **не является ошибкой**.
Вы всего лишь получите значение `nil` в качестве результата

```lua
print(a) --> nil
a = "Hello"
print(a) --> Hello
```
Если вы присвоите `nil` глобальной переменной, то StarfallEx поведет себя так, как если бы эта переменная никогда не использовалась
```lua
b = nil
print(b) --> nil
```
# Комментарии 
> **Комментарий** — это текст, который предназначен для программистов и не обрабатывается компилятором. Обычно комментарии используются для создания заметок к коду для дальнейшего использования.
{.is-info}



```lua
 -- Комментарий начинается в любом месте с двойного дефиса (--) и длится до конца строки кода.
 --[[ 
 	а
    это
      мультистрочный
      комментарий
      тут можно писать что угодно 
 ]]

```
> Так же имеются " // " и " /* */ " комментарии но использование их нежелательно
{.is-warning}

# Типы и значения
> В StarfallEx существует восемь базовых типов: `nil, boolean, number, string, table, function, userdata и thread`

## Логические значения — boolean
> Тип boolean обладает двумя значениями — true и false
{.is-info}

Проверки условий считают nil и false ложными, а все прочие значения истинными. В частности, при
проверках условий StarfallEx считает ноль и пустую строку **истинными значениями**.


## Числа — number
> Тип number представляет вещественные числа, т.е. числа двойной
> точности с плавающей точкой
{.is-info}

Максимально возможное число `math.huge`
Минимально возможное число `math.huge`

Мы можем записывать числовые константы вместе с необязательной
десятичной дробной частью и необязательным десятичным порядком.
Примеры допустимых числовых констант: `4 | 0.4 | .4 | 4.57е-3 | 0.3е12`
Более того, мы также можем использовать шестнадцатеричные
константы, применив префикс 0x: `Oxff | 0х1АЗ | 0x0.2 | 0х1р-1`

## Строки — string

> Строки в StarfallEx являются неизменяемыми значениями. Вы не можете
> изменить символ внутри строки
{.is-info}

вместо этого вы создаете новую строку с необходимыми изменениями, как показано в следующем примере:

```lua
a = "one string"
b = string.gsub(a, "one", "another") -- меняет части строки
print(a) --> "one string"
print(b) --> "another string"
```
> Строка может состоять из одного символа или целой книги.

### Cтроковые литералы
Мы можем определять границы строковых литералов при помощи пар одинарных или двойных кавычек:
```lua
a = "Строка"
b = 'Еще строка'
```
Эти виды записи эквиваленты. 
Единственное отличие состоит в том, что внутри одного вида кавычек вы можете использовать другой, не применяя экраны 

> Экран - `("\"Hi\"" --> "Hi")`

Мы также можем задать символ в строке при помощи его числового
значения через экранированные последовательности `\ddd` и `\x\hh`, где
`ddd` — это последовательность не более чем из трех десятичных цифр, a
`hh` — последовательность ровно из двух шестнадцатеричных цифр
### Дпинные строки
Мы можем задавать строковые литералы при помощи пар из двойных квадратных скобок, как мы делали это с мультистрочными комментариями. 
Литералы в этой скобочной форме могут занимать несколько строк, а экранированные последовательности в этих строках не будут интерпретироваться. Более того, эта форма игнорирует первый символ строки, если это перевод строки. Эта форма особенно удобна для написания строк, содержащих большие фрагменты кода, как в следующем примере:
```lua
LongString = [[
skolko buded kvadrakov esli 
perenesti skroku v
golove
no ne v kode?
]]
print(LongString)

```
Иногда вам может потребоваться заключить в квадратные скобки фрагмент кода, который содержит нечто вроде `a = b[c[i]]` (обратите внимание на `]]` в этом коде) или содержит уже закомментированный фрагмент. Чтобы справиться с подобными ситуациями, вы можете добавить любое количество знаков равенства между двумя открывающими квадратными скобками, например, так: `[===[`. После этого изменения строковый литерал завершится только на следующих закрывающих квадратных скобках с тем же самым количеством знаков равенства (`]===]`)
> Такая же возможность действует и для комментариев.
{.is-info}

### Приведения типов
StarfallEx обеспечивает автоматическое преобразование между числами и строками во время выполнения программ. Любая числовая операция, примененная к строке, пытается преобразовать эту строку в число:
```lua
print("10" + 1) --> 11
print("10 + 1") --> 10 + 1
print("-5.3e-10" * "2") --> -1.06e-09
print("hello" + 1) -- ОШИБКА (невозможно преобразовать "hello")
```
Верно и обратное — каждый раз, когда StarfallEx находит число там, где ожидает строку, он преобразует это число в строку: `print(10 .. 20) --> 1020`
> Операция `..` служит в Lua для конкатенации строк. Когда вы записываете ее сразу после числа, вы должны отделить их друг от друга при помощи пробела, иначе StarfallEx решит, что первая точка — это десятичная точка числа.
{.is-warning}

## Таблицы — table
Тип table представляет ассоциативные массивы.
> Ассоциативный массив — это массив, который может быть индексирован не только числами, но и строками или любым другим значением, кроме nil.
{.is-info}

Таблицы являются главным (на самом деле единственным) механизмом структурирования данных в StarfallEx
> Таблицы в Lua не являются ни значениями, ни переменными. Они объекты.

```lua
a = {} -- создает таблицу и сохраняет ссылку на нее в 'a'
k = "x"
a[k] = 10 -- новая запись с ключом "x" и значением 10
a[20] = "great" -- новая запись с ключом 20 и значением "great"
print(a["x"]) --> 10
k = 20
print(a[k]) --> "great"
a["x"] = a["x"] + 1 -- инкрементирует запись "x"
print(a["x"]) --> 11
```

Каждая таблица может хранить значения с разными типами индексов и растет по мере добавления новых записей:

```lua
a = {} -- пустая таблица
-- создает 1000 новых записей
for i = 1, 1000 do 
	a[i] = i * 2 
end
print(a[9]) --> 18
a["x"] = 10
print(a["x"]) --> 10
print(a["y"]) --> nil
```
Для представления записей вы используете имя поля как индекс. StarfallEx поддерживает это представление, предлагая `a.name` в качестве синтаксического сахара для `a["name"]`. 
Таким образом, мы можем переписать последние строки предыдущего примера следующим, более чистым образом:
```lua
a.x = 10 -- то же, что и a["x"] = 10
print(a.x) -- то же, что и print(a["x"])
print(a.y) -- то же, что и print(a["y"])
```

Типичная ошибка новичков — спутать `а.х` с `а[х]`. Первая форма соответствует `а["х"]`, то есть таблица индексирована при помощи строки "х". Вторая форма означает, что таблица индексирована при помощи значения переменной х. Взгляните на разницу:

```lua
a = {}
x = "y"
a[x] = 10 -- записывает 10 в поле "y"

print(a[x]) --> 10 -- значение поля "y"
print(a.x) --> nil -- значение поля "x" (не определено)
print(a.y) --> 10 -- значение поля "y"
```

## Функции — function

> Функции являются в StarfallEx такими же переменными как и `a = 10`
{.is-info}

функции можно передавать как аргументы для других функций и возвращать функции как результаты. Подобные возможности придают языку огромную гибкость


## Cопрограммы — thread

Тип thread будет разобран в другом, где мы рассмотрим сопрограммы.







# Выражения

## Арифметические операции
StarfallEx поддерживает стандартные арифметические операции:
### Бинарные
- '+' (сложение)
- '-' (вычитание)
- '*' (умножение)
- '/' (деление)
- '^' (возведение в степень)
- '%' (остаток от деления)
и унарную
- '-' (отрицание)

### Операции сравнения
StarfallEx предоставляет следующие операции сравнения:
- < 
- \> 
- <= 
- \>= 
- == 
- ~=
Все эти операции всегда производят **Boolean** значение.


StarfallEx сравнивает таблицы по ссылке, то есть два таких значения считаются равными, только если они являются одним и тем же объектом. Например, после выполнения следующего кода:

```lua
a = {}
  a.x = 1
  a.y = 0
b = {}
  b.x = 1
  b.y = 0
c = a
```
мы получим а == с, но а ~= b.
> StarfallEx сравнивает строки в алфавитном порядке


### Логические операции

> Логические операции — это **and**, **or** и **not**. 
{.is-info}

Как и управляющие структуры, все логические операции трактуют false и nil как ложные, а все остальные — как истинные значения.

Операция **and** возвращает свой первый аргумент, если он ложный, иначе она возвращает свой второй аргумент. Операция **or** возвращает свой первый аргумент, если он не ложный, иначе она возвращает свой второй аргумент:


```lua
print(4 and 5) --> 5
print(nil and 13) --> nil
print(false and 13) --> false
print(4 or 5) --> 4
print(false or 5) --> 5
```

Обе операции, **and** и **or**, используют сокращенное вычисление, то есть они вычисляют свой второй операнд только при необходимости.

Полезной идиомой StarfallEx является `х = х or v`, которая эквивалентна `if not х then х = v end`

To есть значение **x** по умолчанию устанавливается равным значению **v**, если **х** не определен (при условии, что **х** не равен **false**).

Другой полезной идиомой является **(a and b) or с** или просто **a and b or с**, поскольку у **and** более высокий приоритет, чем у **or**.


Например, мы можем выбрать максимум из двух чисел **х** и **у** при помощи такого оператора: `max = (х > у) and х or у`

Когда **х > у**, первое выражение с **and** истинно, поэтому **and** возвращает свое второе выражение (х), которое всегда истинно (поскольку это число), и затем выражение с **or** возвращает значение своего первого выражения (x). 
Когда **х > у** ложно, выражение с **and** тоже ложно, поэтому or возвращает свое второе выражение (y).

Операция **not** всегда возвращает **Boolean** значение:

```lua
print(not nil) --> true
print(not false) --> true
print(not 0) --> false
print(not not 1) --> true
print(not not nil) --> false
```


### Конкатенация

> Конкатенация — это новомодное программистское слово, которое означает «объединить»

Обозначается операция конкатенации строк как `..` (две точки).

```lua
print("Hello " .. "World") --> Hello World
print(0 .. 1) --> 01
print(000 .. 01) --> 01
```

Помните, что строки являются неизменяемыми значениями.
Операция конкатенации всегда создает новую строку

```lua
a = "Hello"
print(a .. " World") --> Hello World
print(a) --> Hello
```

### Операция длины

Операция длины работает со строками и таблицами. Со строками она дает количество байт в строке. С таблицами она возвращает длину представленной ими последовательности.

> Операция длины непредсказуема для списков с дырами (т.е. **nil**). 
{.is-info}

Она работает только для последовательностей, которые определены как списки без дыр. 
```lua
a = {}
a[1] = 1
a[2] = nil -- ничего не делает, так как a[2] уже nil
a[3] = 1
a[4] = 1
```
Легко сказать, что длина этого списка четыре, и у него есть дыра по индексу **2**. 
Однако, что можно сказать о следующем похожем примере?

```lua
a = {}
a[1] = 1
a[10000] = 1
```
Должны ли мы рассматривать a как список с **10000** элементами, где **9998** из них равны `nil`? А теперь программа делает: `a[10000] = nil` ...


Еще более проблемными являются значения `nil` в конце списка. Какой должна быть длина следующего списка?
```lua
a = {10, 20, 30, nil, nil}
```


Поле с nil не отличается от отсутствующего поля. Таким образом, предыдущая таблица эквивалентна `{10,20,30}`
И её длина равна **3**, а не 5.



### Приоритеты операций
Приоритеты операций, от высшего к низшему, следуют этой таблице:

```lua
    ^
    not # -(унарный)
    * / %
    + -
    ..
    < > <= >= ~= ==
    and
    or
```
> Когда сомневаетесь, всегда используйте круглые скобки
{.is-success}


### Конструкторы таблиц

Конструкторы — это выражения, которые создают и инициализируют таблицы.

> Простейший конструктор — это пустой конструктор, `{}`

Конструкторы также инициализируют списки:

```lua
tbl = {"apple", "pineapple", "banana", "bomb", "man"}
print(tbl[4]) --> bomb
```

Также имеется специальный синтаксис для инициализации таблиц:

```lua
a = {x=10, y=20}
```
Эта строка эквивалентна следующим командам:

```lua
a = {}
a.x=10
a.y=20
```

Исходное выражение, тем не менее, проще и быстрее, поскольку сразу создается таблица с правильным размером.


Мы можем смешивать эти два стиля инициализации в одном и том же конструкторе:

```lua
polyline = {
    color="blue",
    thickness=2,
    npoints=4,
    {x=0, y=0}, -- polyline[1]
    {x=-10, y=0}, -- polyline[2]
    {x=-10, y=1}, -- polyline[3]
    {x=0, y=1} -- polyline[4]
}

```
Приведенный выше пример также показывает, как можно вкладывать конструкторы один в другой для представления более сложных структур данных. 

Каждый из элементов `polyline[i]` — это таблица, представляющая собой запись:

```lua
print(polyline[2].x) --> -10
print(polyline[4].y) --> 1
```

У этих двух форм конструктора есть свои ограничения. Например, вы не можете инициализировать поля отрицательными индексами или строковыми индексами, которые не являются правильными идентификаторами. Для таких целей есть другой, более общий формат.

В этом формате мы явно пишем индекс, который должен быть
инициализирован как выражение, между квадратными скобками:

```lua
opnames = {
  ["+"] = "add", ["-"] = "sub",
  ["*"] = "mul", ["/"] = "div"
}
i = 20
s = "+"
a = {
  [i + 0] = s, 
  [i + 1] = s .. s, 
  [i + 2] = s .. s .. s
}
print(opnames[s]) --> sub
print(a[22]) --> +++

```

> Этот синтаксис хоть и более громоздкий, но при этом более гибкий
{.is-info}

Конструктор `{x = 0, y = 0}` эквивалентен `{["x"] = 0, ["y"] = 0}`
Конструктор `{"r", "g", "b"}` эквивалентен `{[1] = "r", [2] = "g", [3] = "b"}`

> Вы всегда можете поставить запятую после последней записи. Эти замыкающие запятые необязательны, но всегда допустимы
{.is-success}

> Вы всегда можете использовать в конструкторе точку с запятой вместо запятой.
{.is-success}


# Операторы

Разделитель между идущими подряд операторами необязателен, но
вы можете использовать точку с запятой, если хотите

```lua
a = 1
b = a * 2
a = 1;
b = a * 2;
a = 1; b = a * 2
a = 1 b = a * 2 -- уродливо, но допустимо
```

## Операторы присваивания

> Присваивание — это базовое средство изменения значения переменной или поля таблицы
{.is-info}

```lua
a = "hello" .. "world"
t.n = t.n + 1

```
Также можно осуществлять множественное присваивание (multiple assignment), которое присваивает список значений списку переменных за один шаг. Например, в присваивании `a, b = 10, 2 * x` переменная **a** получает значение **10**, а переменная **b** — значение **2 * x**
```lua
a, b, c = 0, 1
print(a, b, c) --> 0 1 nil
a, b = a+1, b+1, b+2 -- значение b+2 игнорируется
print(a, b) --> 1 2
a, b, c = 0
print(a, b, c) --> 0 nil nil
```
> Во множественном присваивании сперва вычисляются все значения и только затем выполняются присваивания.

Поэтому мы можем использовать множественное присваивание, чтобы поменять местами два значения, как в следующих примерах:

```lua
x, y = y, x -- меняет местами значения 'x' с 'y'
a[i], a[j] = a[j], a[i] -- меняет местами значения 'a[i]' с 'a[j]'
```

## Локальные переменные и блоки

Кроме глобальных, существуют и локальные переменные. Мы создаем локальные переменные при помощи оператора **local**:

```lua
j = 10 -- глобальная переменная
local i = 1 -- локальная переменная
```

В отличие от глобальных переменных, область видимости локальной переменной ограничена блоком, где она была объявлена.
> Блок — это тело управляющей структуры, тело функции или кусок кода (файл или строка, где переменная была объявлена)
{.is-info}

```lua

x = 10
local i = 1 -- локальная для куска
while i <= x do
  local x = i*2 -- локальная для тела while
  print(x) --> 2, 4, 6, 8, ...
  i = i + 1
  end
  if i > 20 then
    local x -- локальная для тела "then"
    x = 20
    print(x + 2) -- (выведет 22, если условие выполнится)
  else
    print(x) --> 10 (глобальная переменная)
  end
print(x) --> 10 (глобальная переменная)
print(i) --> 10 (локальная переменная cо второй строки)

```

> Хороший стиль программирования заключается в применении локальных переменных везде, где это возможно. Локальные переменные помогают вам избежать засорения глобального окружения ненужными именами. Более того, доступ к локальной переменной быстрее, чем к глобальной.
{.is-success}

> Распространена следующая идиома: `local foo = foo`

Этот код создает локальную переменную foo и инициализирует ее значением глобальной переменной foo (Локальная foo становится видимой только после этого объявления)
Эта идиома удобна, когда куску необходимо предварительно сохранить первоначальное значение переменной, даже если позже какая-нибудь другая функция изменит значение глобальной foo `это также ускоряет доступ к foo.`

## Управляющие конструкции

Существует небольшой и традиционный набор управляющих структур: 

- **if** для условного выполнения
- **while**, **repeat** и **for** для итерации

Все управляющие структуры обладают явным завершающим элементом: 
- end завершает **if**, **for** и **while** 
- а **until** завершает **repeat**.

### if then else

Оператор if проверяет свое условие и в зависимости от результата выполняет одну из своих частей, then или else. .
Часть с else является необязательной.

```lua
if a < 0 then a = 0 end
if a < b then return a else return b end
if line > MAXLINES then
  foo()
  line = 0
end


```
Для записи вложенных операторов if вы можете использовать elseif. 
Это аналогично else, за которым следует if, но при этом не возникает необходимости в нескольких end:

```lua

if op == "+" then
	r = a + b
elseif op == "-" then
	r = a - b
elseif op == "*" then
	r = a*b
elseif op == "/" then
	r = a/b
else
	throw("invalid")
end
```
### while do

Как следует из названия, while повторяет свое тело до тех пор, пока условие **истинно**. Как обычно, сперва проверяется условие while и если оно ложно, то цикл завершаетс, в противном случае выполняется тело цикла и повторяется данный процесс.

```lua
local i = 1
while i < 10 do
  print(i)
  i = i + 1
end
```

### repeat until

Как следует из названия, оператор **repeat–until** повторяет свое тело до тех пор, пока условие не станет истинным. Данный оператор производит проверку условия после выполнения тела, поэтому тело цикла будет выполнено хотя бы один раз


```lua
-- выводит первую непустую введенную строку
a = {1,2,3}
i = 1
repeat
	line = a[i]
  print(line) --> 1, 2, 3, nil
  i = i + 1
until line == nil
print(line) --> nil
```

### for do

Оператор **for** существует в двух вариантах: числовой **for** и общий **for**.
#### Числовой for
Числовой for имеет следующий синтаксис:

```lua
for var = exp1, exp2, exp3 do
	-- Code
end

```
Этот цикл будет выполнять что-либо для каждого значения var от exp1 до ехр2, используя ехр3 как шаг для увеличения var. Это третье выражение необязательно, когда оно отсутствует, считается значение шага равным 1. В качестве типичных примеров можно привести

```lua

for i = 1, f(x) do 
	print(i)
end

for i = 10, 1, -1 do 
	print(i) 
end

```

У цикла for есть некоторые тонкости, которые вам желательно знать, чтобы применять его наиболее эффективно. 
1. Все три выражения вычисляются только один раз, перед началом цикла. Скажем, в нашем первом примере Lua вызовет f(х) всего один раз. 
2. Управляющая переменная является локальной переменной, автоматически объявляемой оператором for, и она видна лишь внутри цикла. 
> Типичная ошибка — полагать, что эта переменная все еще существует после окончания цикла:
{.is-danger}
```lua
for i = 1, 10 do 
	print(i) 
end
max = i -- Очевидно, неправильно!

```
Если вам нужно значение управляющей переменной после цикла, то вы должны сохранить ее значение в другой переменной:

```lua
-- находит значение в списке
a = {1,2,3,0,-5,-4,-1,1}
local found = nil
for i = 1, #a do
  if a[i] < 0 then
    found = a[i] -- сохраняет значение 'i'
    break
  end
end
print(found)

```
3. Вы никогда не должны изменять значение управляющей переменной: эффект подобных изменений не предсказуем.


> Если вы хотите закончить цикл **for** до его нормального завершения, используйте **break** (как в предыдущем примере).
{.is-success}



#### Общий for

Общий for обходит все значения, возвращаемые итерирующей функцией

```lua
-- выводит все значения таблицы 't'
for k, v in pairs(t) do 
	print(k, v) 
end
``` 
Этот пример использует `pairs`, удобную итерирующую функцию для перебора таблицы. На каждом шаге этого цикла **k** получает ключ, a **v** получает значение, связанное с этим ключом.


# Продолжение следует....




















































































































